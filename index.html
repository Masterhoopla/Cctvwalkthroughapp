<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CCTV Checklist — Field Ready</title>
<meta name="theme-color" content="#0b132b"/>

<style>
*{box-sizing:border-box}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial,'Noto Sans',sans-serif;background:#f6f7fb;color:#0b132b}
header{background:#0b132b;color:#fff;padding:16px;text-align:center}
main{padding:16px;max-width:900px;margin:0 auto}
.card{background:#fff;border-radius:16px;box-shadow:0 6px 20px rgba(11,19,43,.08);padding:16px;margin-bottom:16px}
label{display:block;margin:12px 0}
input,textarea,select{width:100%;padding:12px;border:1px solid #dfe3ee;border-radius:12px;background:#fbfcff}
textarea{min-height:90px;resize:vertical}
.row{display:flex;gap:12px;flex-wrap:wrap}
.space-between{justify-content:space-between}.center{align-items:center}
.actions{display:flex;flex-wrap:wrap;gap:10px}
.actions .danger{margin-left:auto}
button{border:0;border-radius:12px;padding:10px 14px;background:#e3e8ff;color:#0b132b;cursor:pointer}
button.primary{background:#3a86ff;color:#fff}
button.danger{background:#ef476f;color:#fff}
.gallery{border:1px dashed #d0d7ea;border-radius:12px;padding:12px;margin:12px 0}
.gallery h3{margin:0 0 8px 0}
.controls{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
.checklist{display:grid;grid-template-columns:min-content 1fr;gap:8px;align-items:start;margin:8px 0}
.checklist input[type=checkbox]{transform:scale(1.2);margin-top:4px}
.photos{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;max-height:260px;overflow:auto;padding-right:6px}
.photos img{max-width:110px;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,.08);display:block}
small.muted{color:#667;display:block;margin-top:6px}
.toast{position:fixed;left:50%;bottom:24px;transform:translateX(-50%);background:#0b132b;color:#fff;padding:10px 14px;border-radius:12px;box-shadow:0 6px 20px rgba(0,0,0,.15);z-index:9999}

/* Photo chip + delete button */
.photo{position:relative;display:inline-block}
.photo img{display:block}
.photo .del{position:absolute;top:-6px;right:-6px;width:22px;height:22px;border-radius:50%;background:#ef476f;color:#fff;border:none;font-size:14px;line-height:22px;text-align:center;cursor:pointer;box-shadow:0 2px 6px rgba(0,0,0,.2)}

/* Floating FABs */
.fab-group{position:fixed; right:18px; bottom:18px; z-index:9999; display:flex; flex-direction:column; gap:10px}
.fab{border:0;border-radius:999px;padding:12px 14px;background:#0b132b;color:#fff;box-shadow:0 6px 20px rgba(0,0,0,.18)}

/* Gallery index (quick jump) */
.gallery-index{display:flex;flex-wrap:wrap;gap:8px;margin:8px 0 4px}
.gallery-index .pill{padding:6px 10px;border-radius:999px;background:#eef2ff;border:1px solid #d6defc;cursor:pointer}
.gallery-index .pill small{opacity:.7}
</style>
</head>
<body>
  <header>
    <h1>CCTV Pre-Installation Checklist</h1>
  </header>

  <main>
    <!-- Customer Profile -->
    <section class="card">
      <h2>Customer Profile</h2>
      <label>
        Customer Name
        <input type="text" id="customerName" placeholder="Customer Name"/>
      </label>
      <label>
        Address
        <input type="text" id="customerAddress" placeholder="Address"/>
      </label>
      <label>
        Contact Name
        <input type="text" id="contactName" placeholder="Primary contact name"/>
      </label>
      <label>
        Contact Phone
        <input type="tel" id="contactPhone" placeholder="(555) 555-5555"/>
      </label>
      <label>
        Contact Email
        <input type="email" id="contactEmail" placeholder="name@example.com"/>
      </label>
    </section>

    <!-- General Notes -->
    <section class="card">
      <h2>General Notes</h2>
      <label>
        <textarea id="customerNotes" placeholder="Notes about this walkthrough"></textarea>
      </label>
    </section>

    <!-- Galleries -->
    <section class="card">
      <div class="row space-between center">
        <h2>Galleries</h2>
        <button class="primary" id="btnAddGallery">Add Gallery</button>
      </div>
      <div id="galleryIndex" class="gallery-index" aria-label="Gallery quick navigation"></div>
      <div id="galleries" aria-live="polite"></div>
    </section>

    <!-- Actions -->
    <section class="actions">
      <button id="btnExport" class="primary">Download PDF Report</button>
      <button id="btnSave">Save</button>
      <button id="btnExportSave">Export Save</button>
      <button id="btnImportSave">Import Save</button>
      <button id="btnZipPhotos">Download All Photos (ZIP)</button>
      <button id="btnReset" class="danger">Reset</button>
    </section>
  </main>

  <!-- Floating FABs -->
  <div class="fab-group">
    <button id="btnFabAdd" class="fab" title="Add gallery">＋ Gallery</button>
    <button id="btnTop" class="fab" aria-label="Back to top">↑ Top</button>
  </div>

  <!-- jsPDF for PDF export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <!-- JSZip for ZIP downloads -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js" crossorigin="anonymous"></script>

  <script>
  // ---------- State ----------
  let state = {
    customer: {
      name: '', address: '',
      contactName: '', contactPhone: '', contactEmail: '',
      notes: ''
    },
    galleries: []
  };

  const el = (id) => document.getElementById(id);
  const galleriesEl = el('galleries');
  const galleryIndexEl = el('galleryIndex');

  // ---------- Init ----------
  load();
  render();

  // Live-sync customer fields
  el('customerName').addEventListener('input', e => { state.customer.name = e.target.value; save(); });
  el('customerAddress').addEventListener('input', e => { state.customer.address = e.target.value; save(); });
  el('contactName').addEventListener('input', e => { state.customer.contactName = e.target.value; save(); });
  el('contactPhone').addEventListener('input', e => { state.customer.contactPhone = e.target.value; save(); });
  el('contactEmail').addEventListener('input', e => { state.customer.contactEmail = e.target.value; save(); });
  el('customerNotes').addEventListener('input', e => { state.customer.notes = e.target.value; save(); });

  // Buttons
  const addGalleryHandlers = () => onAddGallery();
  el('btnAddGallery').addEventListener('click', addGalleryHandlers);
  el('btnFabAdd').addEventListener('click', addGalleryHandlers);

  el('btnExport').addEventListener('click', generatePDF);
  el('btnSave').addEventListener('click', () => { save(); toast('Saved'); });
  el('btnExportSave').addEventListener('click', exportSave);
  el('btnImportSave').addEventListener('click', importSave);
  el('btnZipPhotos').addEventListener('click', downloadAllPhotosZip);
  el('btnReset').addEventListener('click', () => {
    if (confirm('Clear all data?')) {
      state = { customer:{name:'',address:'',contactName:'',contactPhone:'',contactEmail:'',notes:''}, galleries:[] };
      save(); render();
    }
  });
  el('btnTop').addEventListener('click', () => { window.scrollTo({ top: 0, behavior: 'smooth' }); });

  // ---------- UI / Data ----------
  function onAddGallery(){
    const name = prompt('Enter gallery name:');
    if (!name) return;
    state.galleries.push({
      name: name.trim(),
      actions: { add:false, replace:false, relocate:false, remove:false },
      note: '',
      photos: []
    });
    save(); render(); toast('Gallery added');

    // Auto-scroll to the new gallery
    requestAnimationFrame(() => {
      const items = document.querySelectorAll('.gallery');
      const last = items[items.length - 1];
      if (last) last.scrollIntoView({ behavior:'smooth', block:'start' });
    });
  }

  function render(){
    // header fields
    el('customerName').value   = state.customer.name || '';
    el('customerAddress').value= state.customer.address || '';
    el('contactName').value    = state.customer.contactName || '';
    el('contactPhone').value   = state.customer.contactPhone || '';
    el('contactEmail').value   = state.customer.contactEmail || '';
    el('customerNotes').value  = state.customer.notes || '';

    // Gallery quick index
    galleryIndexEl.innerHTML = '';
    state.galleries.forEach((g, idx) => {
      const pill = document.createElement('button');
      pill.className = 'pill';
      pill.innerHTML = `${escapeHtml(g.name)} <small>(${g.photos.length})</small>`;
      pill.addEventListener('click', () => {
        const target = document.getElementById('gal-' + idx);
        if (target) target.scrollIntoView({ behavior:'smooth', block:'start' });
      });
      galleryIndexEl.appendChild(pill);
    });

    // galleries
    galleriesEl.innerHTML = '';
    state.galleries.forEach((g, idx) => {
      const wrap = document.createElement('div');
      wrap.className = 'gallery';
      wrap.id = 'gal-' + idx;
      wrap.innerHTML = `
        <div class="row space-between center">
          <h3>${escapeHtml(g.name)}</h3>
          <div class="controls">
            <button data-act="photo" data-i="${idx}">Add Photo</button>
            <button data-act="rename" data-i="${idx}">Rename</button>
            <button data-act="up" data-i="${idx}">Move ↑</button>
            <button data-act="down" data-i="${idx}">Move ↓</button>
            <button class="danger" data-act="delete" data-i="${idx}">Remove</button>
          </div>
        </div>

        <div class="checklist">
          <input type="checkbox" id="add-${idx}" ${g.actions.add?'checked':''} />
          <label for="add-${idx}">Add</label>

          <input type="checkbox" id="replace-${idx}" ${g.actions.replace?'checked':''} />
          <label for="replace-${idx}">Replace</label>

          <input type="checkbox" id="relocate-${idx}" ${g.actions.relocate?'checked':''} />
          <label for="relocate-${idx}">Relocate</label>

          <input type="checkbox" id="remove-${idx}" ${g.actions.remove?'checked':''} />
          <label for="remove-${idx}">Remove</label>
        </div>

        <div class="note">
          <label>Notes
            <textarea id="note-${idx}" placeholder="Notes for this gallery">${escapeHtml(g.note)}</textarea>
          </label>
          <small class="muted">Tip: use the checklist above to mark planned work.</small>
        </div>

        <div class="photos" id="photos-${idx}"></div>
      `;

      // photos with delete (×)
      const photosWrap = wrap.querySelector('#photos-' + idx);
      g.photos.forEach((src, pIndex) => {
        const holder = document.createElement('div');
        holder.className = 'photo';

        const img = new Image();
        img.src = src; img.alt = 'gallery photo';
        holder.appendChild(img);

        const del = document.createElement('button');
        del.className = 'del';
        del.textContent = '×';
        del.title = 'Delete photo';
        del.addEventListener('click', () => {
          if (confirm('Delete this photo?')){
            g.photos.splice(pIndex, 1);
            save(); render();
          }
        });
        holder.appendChild(del);

        photosWrap.appendChild(holder);
      });

      // checklist bindings
      wrap.querySelectorAll('input[type=checkbox]').forEach(cb => {
        cb.addEventListener('change', () => {
          const k = cb.id.split('-')[0];
          g.actions[k] = cb.checked; save();
        });
      });

      // note binding
      const ta = wrap.querySelector('textarea');
      ta.addEventListener('input', (e) => { g.note = e.target.value; save(); });

      // buttons
      wrap.querySelectorAll('button[data-act]').forEach(btn => {
        btn.addEventListener('click', () => {
          const act = btn.getAttribute('data-act');
          if (act === 'photo') addPhoto(idx);
          if (act === 'rename') {
            const newName = prompt('New gallery name:', g.name);
            if (newName) { g.name = newName.trim(); save(); render(); }
          }
          if (act === 'delete') {
            if (confirm('Delete this gallery?')) { state.galleries.splice(idx,1); save(); render(); }
          }
          if (act === 'up' && idx > 0){
            const tmp = state.galleries[idx-1];
            state.galleries[idx-1] = state.galleries[idx];
            state.galleries[idx] = tmp; save(); render();
            document.getElementById('gal-' + (idx-1))?.scrollIntoView({behavior:'smooth', block:'start'});
          }
          if (act === 'down' && idx < state.galleries.length-1){
            const tmp = state.galleries[idx+1];
            state.galleries[idx+1] = state.galleries[idx];
            state.galleries[idx] = tmp; save(); render();
            document.getElementById('gal-' + (idx+1))?.scrollIntoView({behavior:'smooth', block:'start'});
          }
        });
      });

      galleriesEl.appendChild(wrap);
    });
  }

  async function addPhoto(index){
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.capture = 'environment';
    input.onchange = async e => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      try {
        let orientedAlready = false;
        try { await createImageBitmap(file, { imageOrientation: 'from-image' }); orientedAlready = true; } catch {}

        const fixedDataUrl = await fixImageOrientationAndScale(file, { maxDim: 1400, quality: 0.80, skipOrientation: orientedAlready });
        state.galleries[index].photos.push(fixedDataUrl);
        save(); render();

        const scroller = document.getElementById('photos-' + index);
        if (scroller) scroller.scrollTop = scroller.scrollHeight;
      } catch (err) {
        console.warn('Image normalize failed; falling back to raw', err);
        const reader = new FileReader();
        reader.onload = () => { state.galleries[index].photos.push(reader.result); save(); render(); };
        reader.readAsDataURL(file);
      }
    };
    input.click();
  }

  // ---------- Storage ----------
  function save(){ try{ localStorage.setItem('cctv-checklist', JSON.stringify(state)); }catch(e){ console.warn(e); } }
  function load(){
    try{
      const raw = localStorage.getItem('cctv-checklist');
      if (raw) state = JSON.parse(raw);
    }catch(e){ console.warn('Failed to load state', e); }
  }

  function exportSave(){
    try{
      const data = JSON.stringify(state, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const safe = s => (s || 'Customer').replace(/[^\w\-]+/g, '_').slice(0, 60);
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      a.download = `${safe(state.customer.name)}_Checklist_${ts}.json`;
      a.href = url;
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
      toast('Save exported');
    }catch(e){ console.warn(e); toast('Export failed'); }
  }

  function importSave(){
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'application/json';
    input.onchange = e => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try{
          const obj = JSON.parse(reader.result);
          if (!obj || typeof obj !== 'object' || !obj.customer || !Array.isArray(obj.galleries)){
            throw new Error('Invalid save file');
          }
          state = obj; save(); render(); toast('Save imported');
        } catch(err){
          console.warn(err);
          alert('Could not import that file. Is it a valid checklist JSON export?');
        }
      };
      reader.readAsText(file);
    };
    input.click();
  }

  // ---------- ZIP download of all photos ----------
  function dataURLtoBlob(dataURL){
    const [meta, data] = dataURL.split(',');
    const isBase64 = /;base64$/i.test(meta);
    const mime = (meta.match(/data:(.*?)(;|,)/)||[])[1] || 'application/octet-stream';
    const bytes = isBase64 ? atob(data) : decodeURIComponent(data);
    const buf = new Uint8Array(bytes.length);
    for (let i=0; i<bytes.length; i++) buf[i] = bytes.charCodeAt(i);
    return new Blob([buf], { type: mime });
  }
  function downloadBlob(filename, blob){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  }
  async function downloadAllPhotosZip(){
    if (!window.JSZip){ alert('ZIP library not loaded'); return; }
    const zip = new JSZip();
    const safe = s => (s || 'Customer').replace(/[^\w\-]+/g, '_').slice(0,60);

    let count = 0;
    for (const g of state.galleries){
      const folder = zip.folder(safe(g.name) || 'Gallery');
      for (let i=0;i<g.photos.length;i++){
        const src = g.photos[i];
        const blob = dataURLtoBlob(src);
        folder.file(`${safe(state.customer.name)}_${safe(g.name)}_${i+1}.jpg`, blob);
        count++;
      }
    }

    if (count === 0){ toast('No photos to zip'); return; }
    const content = await zip.generateAsync({ type:'blob' });
    const today = new Date();
    const ymd = `${today.getFullYear()}-${String(today.getMonth()+1).padStart(2,'0')}-${String(today.getDate()).padStart(2,'0')}`;
    const filename = `${safe(state.customer.name)}_Photos_${ymd}.zip`;
    downloadBlob(filename, content);
  }

  // ---------- PDF ----------
  async function generatePDF(){
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit:'pt', format:'a4' });

    // Layout
    const M = 40;
    const W = doc.internal.pageSize.getWidth();
    const H = doc.internal.pageSize.getHeight();
    const U = W - M*2;
    const LINE = 12;

    // Header (centered name + subtitle)
    let y = M;
    doc.setFont('helvetica','bold'); doc.setFontSize(16);
    const headerName = (state.customer.name || '').trim() || 'Customer';
    centerText(doc, headerName, W, y); y += 20;

    doc.setFont('helvetica','bold'); doc.setFontSize(14);
    centerText(doc, 'Pre-Installation Walkthrough Report', W, y); y += 18;

    drawHr(doc, M, y, U); y += 14;

    // Customer Summary Box (dynamic height)
    const boxPadTop = 20, boxPadSide = 10;
    let need = 0;
    doc.setFont('helvetica','bold'); doc.setFontSize(12); need += 14;
    doc.setFont('helvetica','normal'); doc.setFontSize(11);
    need += measureLabelValueHeight(doc, 'Customer',      state.customer.name || '', U - 20, LINE);
    need += measureLabelValueHeight(doc, 'Address',       state.customer.address || '', U - 20, LINE);
    need += measureLabelValueHeight(doc, 'Contact Name',  state.customer.contactName || '', U - 20, LINE);
    need += measureLabelValueHeight(doc, 'Contact Phone', state.customer.contactPhone || '', U - 20, LINE);
    need += measureLabelValueHeight(doc, 'Contact Email', state.customer.contactEmail || '', U - 20, LINE);
    const boxH = boxPadTop + need + 10;

    y = addPageIfNeeded(doc, y, H, M, boxH + 16);
    drawBox(doc, M, y, U, boxH);
    let bx = M + boxPadSide, by = y + boxPadTop;

    doc.setFont('helvetica','bold'); doc.setFontSize(12);
    doc.text('Customer Summary', bx, by); by += 14;

    doc.setFont('helvetica','normal'); doc.setFontSize(11);
    by = writeLabelValue(doc, 'Customer',      state.customer.name || '',        bx, by, U - 2*boxPadSide, LINE);
    by = writeLabelValue(doc, 'Address',       state.customer.address || '',     bx, by, U - 2*boxPadSide, LINE);
    by = writeLabelValue(doc, 'Contact Name',  state.customer.contactName || '', bx, by, U - 2*boxPadSide, LINE);
    by = writeLabelValue(doc, 'Contact Phone', state.customer.contactPhone || '',bx, by, U - 2*boxPadSide, LINE);
    by = writeLabelValue(doc, 'Contact Email', state.customer.contactEmail || '',bx, by, U - 2*boxPadSide, LINE);

    y += boxH + 16;

    // General Notes (own section; can span pages)
    const notes = (state.customer.notes || '').trim();
    if (notes){
      y = addPageIfNeeded(doc, y, H, M, 80);
      drawSectionHeader(doc, 'General Notes', M, y, U);
      y += 28;
      doc.setFont('helvetica','normal'); doc.setFontSize(11);
      y = wrapText(doc, notes, M, y, U, 14) + 6;
      drawHr(doc, M, y, U); y += 12;
    }

    // ===== Galleries =====
    if (!state.galleries.length){
      doc.setFont('helvetica','italic'); doc.setFontSize(12);
      doc.text('No galleries added.', M, y); y += 20;
    } else {
      for (let gi = 0; gi < state.galleries.length; gi++){
        const g = state.galleries[gi];

        // Only start a new page if header won't fit
        const HEADER_H = 28;
        if (y + HEADER_H > H - M){
          doc.addPage();
          y = M;
        }

        // Section header
        drawSectionHeader(doc, `Gallery: ${g.name}`, M, y, U);
        y += HEADER_H;

        // Checklist ✓
        const actions = [
          ['Add', !!g.actions.add],
          ['Replace', !!g.actions.replace],
          ['Relocate', !!g.actions.relocate],
          ['Remove', !!g.actions.remove],
        ];
        doc.setFont('helvetica','normal'); doc.setFontSize(11);
        const actionLine = actions.filter(a => a[1]).map(a => `✓ ${a[0]}`).join('   ');
        if (actionLine){ doc.text(actionLine, M, y); y += 16; }

        // Notes
        const gnote = (g.note || '').trim();
        if (gnote){ y = wrapText(doc, `Notes: ${gnote}`, M, y, U, 12) + 8; }

        // Photos grid with continued header on overflow pages
        if (g.photos && g.photos.length){
          const continuedHeader = (d) => {
            drawSectionHeader(d, `Gallery: ${g.name} — continued`, M, M, U);
          };

          y = drawPhotoGrid(doc, g.photos, {
            x: M, y, usableWidth: U,
            perRow: 3, thumbW: 165, thumbH: 110, gap: 10,
            pageH: H, margin: M,
            onNewPage: continuedHeader
          });
          y += 10;
        } else {
          doc.setFont('helvetica','italic'); doc.setFontSize(11);
          doc.text('No photos.', M, y); y += 14;
        }

        // underline after gallery; do NOT force a new page
        drawHr(doc, M, y, U);
        y += 12; // breathing room before next gallery
      }
    }

    // Footer: generated date (left) + page numbers (right)
    numberPages(doc, (pageNum, pageCount) => {
      doc.setFont('helvetica','normal'); doc.setFontSize(9);
      doc.setTextColor(120);
      const when = new Date().toLocaleString();
      const Wp = doc.internal.pageSize.getWidth();
      const Hp = doc.internal.pageSize.getHeight();
      doc.text(when, M, Hp - 20);
      const text = `Page ${pageNum} of ${pageCount}`;
      const tw = doc.getTextWidth(text);
      doc.text(text, Wp - M - tw, Hp - 20);
      doc.setTextColor(0);
      return '';
    });

    const safe = s => (s || 'Customer').replace(/[^\w\-]+/g, '_').slice(0, 60);
    const today = new Date();
    const ymd = `${today.getFullYear()}-${String(today.getMonth()+1).padStart(2,'0')}-${String(today.getDate()).padStart(2,'0')}`;
    const suggested = `${safe(state.customer.name)}_Walkthrough_${ymd}.pdf`;
    const name = prompt('File name for the PDF:', suggested) || suggested;

    doc.save(name);
  }

  // ---------- Helpers ----------
  function drawHr(doc, x, y, w){
    doc.setDrawColor(200); doc.setLineWidth(0.8);
    doc.line(x, y, x + w, y);
    doc.setDrawColor(0); doc.setLineWidth(0.2);
  }

  function drawBox(doc, x, y, w, h){
    doc.setDrawColor(220); doc.setFillColor(248,249,252);
    doc.roundedRect(x, y, w, h, 6, 6, 'FD');
    doc.setDrawColor(0);
  }

  function measureLabelValueHeight(doc, label, value, maxW, lineH){
    const lines = doc.splitTextToSize(value || '', maxW - 95);
    return Math.max(lineH, lines.length * lineH);
  }

  function writeLabelValue(doc, label, value, x, y, maxW, lineH){
    doc.setFont('helvetica','bold'); doc.setFontSize(11);
    doc.text(`${label}:`, x, y);
    const start = x + 95;
    doc.setFont('helvetica','normal');
    const lines = doc.splitTextToSize(value || '', maxW - 95);
    lines.forEach((ln, i) => doc.text(ln, start, y + i*lineH));
    return y + Math.max(lineH, lines.length*lineH);
  }

  function drawSectionHeader(doc, title, x, y, w){
    doc.setFillColor(238,242,255);
    doc.setDrawColor(210,220,255);
    doc.roundedRect(x, y-20, w, 28, 6, 6, 'FD');
    doc.setFont('helvetica','bold'); doc.setFontSize(13);
    doc.setTextColor(30, 41, 59);
    doc.text(title, x + 10, y);
    doc.setTextColor(0,0,0);
  }

  function addPageIfNeeded(doc, y, pageH, margin, needed){
    if (y + needed <= pageH - margin) return y;
    doc.addPage();
    return margin;
  }

  function wrapText(doc, text, x, y, maxWidth, lineH=12){
    const lines = doc.splitTextToSize(text, maxWidth);
    for (const ln of lines){
      if (y > doc.internal.pageSize.getHeight() - 40){ doc.addPage(); y = 40; }
      doc.text(ln, x, y);
      y += lineH;
    }
    return y;
  }

  function drawPhotoGrid(doc, photos, opts){
    const { x, y: yStart, usableWidth, perRow=3, thumbW=165, thumbH=110, gap=10, pageH, margin, onNewPage } = opts;

    let cy = yStart;
    let pr = perRow;
    while ((pr * thumbW + (pr - 1) * gap) > usableWidth && pr > 1) pr--;

    for (let i = 0; i < photos.length; i += pr){
      const row = photos.slice(i, i + pr);

      if (cy + thumbH > pageH - margin){
        doc.addPage();
        cy = margin;
        if (typeof onNewPage === 'function') onNewPage(doc);
        cy += 28;
      }

      const totalW = row.length * thumbW + (row.length - 1) * gap;
      let cx = x + Math.max(0, (usableWidth - totalW) / 2);

      for (const src of row){
        try { doc.addImage(src, 'JPEG', cx, cy, thumbW, thumbH); } catch {}
        cx += thumbW + gap;
      }
      cy += thumbH + gap;
    }
    return cy - gap;
  }

  function numberPages(doc, formatter){
    const pageCount = doc.getNumberOfPages();
    for (let i=1; i<=pageCount; i++){
      doc.setPage(i);
      formatter(i, pageCount);
    }
  }

  function centerText(doc, text, pageWidth, y){
    const tw = doc.getTextWidth(text);
    const x = (pageWidth - tw) / 2;
    doc.text(text, x, y);
  }

  function escapeHtml(s=''){
    return s.replace(/[&<>"']/g, c => ({
      '&':'&amp;',
      '<':'&lt;',
      '>':'&gt;',
      '"':'&quot;',
      "'":'&#39;'
    }[c]));
  }

  function toast(msg){
    const t = document.createElement('div');
    t.className = 'toast';
    t.textContent = msg;
    document.body.appendChild(t);
    setTimeout(()=>t.remove(), 1300);
  }

  // ---------- Image orientation helpers ----------
  function readExifOrientation(arrayBuffer){
    const dv = new DataView(arrayBuffer);
    if (dv.getUint16(0, false) !== 0xFFD8) return 1;
    let offset = 2;
    const length = dv.byteLength;
    while (offset < length) {
      const marker = dv.getUint16(offset, false); offset += 2;
      if (marker === 0xFFE1) {
        const exifLength = dv.getUint16(offset, false); offset += 2;
        if (dv.getUint32(offset, false) !== 0x45786966) return 1;
        offset += 6;
        const tiffOffset = offset;
        const little = dv.getUint16(tiffOffset, false) === 0x4949;
        const firstIFDOffset = dv.getUint32(tiffOffset + 4, little);
        let ifdOffset = tiffOffset + firstIFDOffset;
        const entries = dv.getUint16(ifdOffset, little); ifdOffset += 2;
        for (let i=0; i<entries; i++){
          const entryOffset = ifdOffset + i*12;
          const tag = dv.getUint16(entryOffset, little);
          if (tag === 0x0112){
            const val = dv.getUint16(entryOffset + 8, little);
            return val || 1;
          }
        }
        return 1;
      } else if ((marker & 0xFFF0) !== 0xFFE0) {
        break;
      } else {
        offset += dv.getUint16(offset, false);
      }
    }
    return 1;
  }

  function drawOriented(ctx, img, width, height, orientation){
    switch (orientation) {
      case 2: ctx.translate(width, 0); ctx.scale(-1, 1); break;
      case 3: ctx.translate(width, height); ctx.rotate(Math.PI); break;
      case 4: ctx.translate(0, height); ctx.scale(1, -1); break;
      case 5: ctx.rotate(0.5*Math.PI); ctx.scale(1, -1); [width, height] = [height, width]; break;
      case 6: ctx.rotate(0.5*Math.PI); ctx.translate(0, -height); [width, height] = [height, width]; break;
      case 7: ctx.rotate(0.5*Math.PI); ctx.translate(width, -height); ctx.scale(-1, 1); [width, height] = [height, width]; break;
      case 8: ctx.rotate(-0.5*Math.PI); ctx.translate(-width, 0); [width, height] = [height, width]; break;
      default: break;
    }
    return { width, height };
  }

  async function fixImageOrientationAndScale(file, { maxDim = 1400, quality = 0.80, skipOrientation = false } = {}){
    let orientation = 1;
    if (!skipOrientation){
      try { const buf = await file.arrayBuffer(); orientation = readExifOrientation(buf) || 1; } catch {}
    }

    let bitmap;
    try {
      bitmap = await createImageBitmap(file, { imageOrientation: 'from-image' });
    } catch {
      const url = URL.createObjectURL(file);
      bitmap = await new Promise((res, rej) => {
        const img = new Image();
        img.onload = () => { res(img); URL.revokeObjectURL(url); };
        img.onerror = rej;
        img.src = url;
      });
    }

    let iw = bitmap.width, ih = bitmap.height;
    let tw = iw, th = ih;
    const longSide = Math.max(iw, ih);
    if (longSide > maxDim) {
      const scale = maxDim / longSide;
      tw = Math.round(iw * scale);
      th = Math.round(ih * scale);
    }

    const rotates90 = !skipOrientation && [5,6,7,8].includes(orientation);
    const canvas = document.createElement('canvas');
    canvas.width  = rotates90 ? th : tw;
    canvas.height = rotates90 ? tw : th;
    const ctx = canvas.getContext('2d');

    const dim = skipOrientation ? { width: tw, height: th } : drawOriented(ctx, bitmap, canvas.width, canvas.height, orientation);
    ctx.drawImage(bitmap, 0, 0, dim.width, dim.height);

    return canvas.toDataURL('image/jpeg', quality);
  }
  </script>
</body>
</html>
