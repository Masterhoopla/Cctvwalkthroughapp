<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CCTV Checklist — Single-File Baseline</title>
<meta name="theme-color" content="#0b132b"/>

<style>
/* ==== Inline baseline styles (no external CSS) ==== */
*{box-sizing:border-box}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial,'Noto Sans',sans-serif;background:#f6f7fb;color:#0b132b}
header{background:#0b132b;color:#fff;padding:16px;text-align:center}
main{padding:16px;max-width:900px;margin:0 auto}
.card{background:#fff;border-radius:16px;box-shadow:0 6px 20px rgba(11,19,43,.08);padding:16px;margin-bottom:16px}
label{display:block;margin:12px 0}
input,textarea,select{width:100%;padding:12px;border:1px solid #dfe3ee;border-radius:12px;background:#fbfcff}
textarea{min-height:90px;resize:vertical}
.row{display:flex;gap:12px;flex-wrap:wrap}
.space-between{justify-content:space-between}.center{align-items:center}
button{border:0;border-radius:12px;padding:10px 14px;background:#e3e8ff;color:#0b132b;cursor:pointer}
button.primary{background:#3a86ff;color:#fff}button.danger{background:#ef476f;color:#fff}
.gallery{border:1px dashed #d0d7ea;border-radius:12px;padding:12px;margin:12px 0}
.gallery h3{margin:0 0 8px 0}
.controls{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
.checklist{display:grid;grid-template-columns:min-content 1fr;gap:8px;align-items:start;margin:8px 0}
.checklist input[type=checkbox]{transform:scale(1.2);margin-top:4px}
.photos{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;max-height:260px;overflow:auto;padding-right:6px}
.photos img{max-width:110px;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,.08);display:block}
small.muted{color:#667;display:block;margin-top:6px}
.toast{position:fixed;left:50%;bottom:24px;transform:translateX(-50%);background:#0b132b;color:#fff;padding:10px 14px;border-radius:12px;box-shadow:0 6px 20px rgba(0,0,0,.15);z-index:9999}
</style>
</head>
<body>
  <header>
    <h1>CCTV Pre-Installation Checklist — Baseline</h1>
  </header>

  <main>
    <section class="card">
      <h2>Customer Profile</h2>
      <label>
        Customer Name
        <input type="text" id="customerName" placeholder="Customer Name"/>
      </label>
      <label>
        Address
        <input type="text" id="customerAddress" placeholder="Address"/>
      </label>
      <label>
        General Notes
        <textarea id="customerNotes" placeholder="Notes about this walkthrough"></textarea>
      </label>
    </section>

    <section class="card">
      <div class="row space-between center">
        <h2>Galleries</h2>
        <button class="primary" id="btnAddGallery">Add Gallery</button>
      </div>
      <div id="galleries" aria-live="polite"></div>
    </section>

    <section class="actions">
      <button id="btnExport" class="primary">Download PDF Report</button>
      <button id="btnSave">Save</button>
      <button id="btnReset" class="danger">Reset</button>
    </section>
  </main>

  <!-- jsPDF CDN for PDF export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <!-- ==== Inline App JS (no external file) ==== -->
  <script>
  // Visible proof this HTML loaded
  console.log('INDEX single-file baseline loaded');

  let state = {
    customer: { name: '', address: '', notes: '' },
    galleries: []
  };

  const el = (id) => document.getElementById(id);
  const galleriesEl = el('galleries');

  // Init
  load();
  render();

  // Bindings
  el('btnAddGallery').addEventListener('click', onAddGallery);
  el('btnExport').addEventListener('click', generatePDF);
  el('btnSave').addEventListener('click', () => { collectHeader(); save(); toast('Saved'); });
  el('btnReset').addEventListener('click', () => {
    if (confirm('Clear all data?')) { state = { customer:{name:'',address:'',notes:''}, galleries:[] }; save(); render(); }
  });

  function onAddGallery(){
    const name = prompt('Enter gallery name:');
    if (!name) return;
    state.galleries.push({
      name: name.trim(),
      actions: { add:false, replace:false, relocate:false, remove:false },
      note: '',
      photos: []
    });
    save(); render(); toast('Gallery added');
  }

  function collectHeader(){
    state.customer.name = el('customerName').value.trim();
    state.customer.address = el('customerAddress').value.trim();
    state.customer.notes = el('customerNotes').value.trim();
  }

  function render(){
    // header
    el('customerName').value = state.customer.name || '';
    el('customerAddress').value = state.customer.address || '';
    el('customerNotes').value = state.customer.notes || '';

    // galleries
    galleriesEl.innerHTML = '';
    state.galleries.forEach((g, idx) => {
      const wrap = document.createElement('div');
      wrap.className = 'gallery';
      wrap.innerHTML = `
        <div class="row space-between center">
          <h3>${escapeHtml(g.name)}</h3>
          <div class="controls">
            <button data-act="photo" data-i="${idx}">Add Photo</button>
            <button data-act="rename" data-i="${idx}">Rename</button>
            <button class="danger" data-act="delete" data-i="${idx}">Remove</button>
          </div>
        </div>

        <div class="checklist">
          <input type="checkbox" id="add-${idx}" ${g.actions.add?'checked':''} />
          <label for="add-${idx}">Add</label>

          <input type="checkbox" id="replace-${idx}" ${g.actions.replace?'checked':''} />
          <label for="replace-${idx}">Replace</label>

          <input type="checkbox" id="relocate-${idx}" ${g.actions.relocate?'checked':''} />
          <label for="relocate-${idx}">Relocate</label>

          <input type="checkbox" id="remove-${idx}" ${g.actions.remove?'checked':''} />
          <label for="remove-${idx}">Remove</label>
        </div>

        <div class="note">
          <label>Notes
            <textarea id="note-${idx}" placeholder="Notes for this gallery">${escapeHtml(g.note)}</textarea>
          </label>
          <small class="muted">Tip: use the checklist above to mark planned work.</small>
        </div>

        <div class="photos" id="photos-${idx}"></div>
      `;

      // Render photos explicitly
      const photosWrap = wrap.querySelector('#photos-' + idx);
      g.photos.forEach(src => {
        const img = new Image();
        img.src = src;
        img.alt = 'gallery photo';
        photosWrap.appendChild(img);
      });

      // Bind checkbox changes
      wrap.querySelectorAll('input[type=checkbox]').forEach(cb => {
        cb.addEventListener('change', () => {
          const k = cb.id.split('-')[0];
          g.actions[k] = cb.checked; save();
        });
      });

      // Bind note
      const ta = wrap.querySelector('textarea');
      ta.addEventListener('input', (e) => { g.note = e.target.value; save(); });

      // Buttons
      wrap.querySelectorAll('button[data-act]').forEach(btn => {
        btn.addEventListener('click', () => {
          const act = btn.getAttribute('data-act');
          if (act === 'photo') addPhoto(idx);
          if (act === 'rename') {
            const newName = prompt('New gallery name:', g.name);
            if (newName) { g.name = newName.trim(); save(); render(); }
          }
          if (act === 'delete') {
            if (confirm('Delete this gallery?')) { state.galleries.splice(idx,1); save(); render(); }
          }
        });
      });

      galleriesEl.appendChild(wrap);
    });
  }

async function addPhoto(index){
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'image/*';
  input.capture = 'environment';
  input.onchange = async e => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;

    try {
      // Normalize orientation + optionally downscale for smaller PDFs
      const fixedDataUrl = await fixImageOrientationAndScale(file, { maxDim: 1600, quality: 0.85 });
      state.galleries[index].photos.push(fixedDataUrl);
      save(); render();

      const scroller = document.getElementById('photos-' + index);
      if (scroller) scroller.scrollTop = scroller.scrollHeight;
    } catch (err) {
      console.warn('Image fix failed, falling back to raw', err);
      // Fallback to raw (may be rotated in PDF)
      const reader = new FileReader();
      reader.onload = () => {
        state.galleries[index].photos.push(reader.result);
        save(); render();
      };
      reader.readAsDataURL(file);
    }
  };
  input.click();
}


  // Storage
  function save(){ try{ localStorage.setItem('cctv-checklist', JSON.stringify(state)); }catch(e){ console.warn(e); } }
  function load(){
    try{
      const raw = localStorage.getItem('cctv-checklist');
      if (raw) state = JSON.parse(raw);
    }catch(e){ console.warn('Failed to load state', e); }
  }

  // PDF
  async function generatePDF(){
    collectHeader();
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit:'pt', format:'a4' });
    let y = 40;

    doc.setFontSize(18);
    doc.text('CCTV Pre-Installation Report', 40, y); y += 24;
    doc.setFontSize(12);
    doc.text(`Customer: ${state.customer.name || ''}`, 40, y); y += 18;
    doc.text(`Address: ${state.customer.address || ''}`, 40, y); y += 18;
    if (state.customer.notes){ doc.text('Notes:', 40, y); y += 16; y = wrapText(doc, state.customer.notes, 40, y, 515); y += 8; }

    for (const g of state.galleries){
      if (y > 760) { doc.addPage(); y = 40; }
      doc.setFontSize(14);
      doc.text(`Gallery: ${g.name}`, 40, y); y += 18;

      const acts = Object.entries(g.actions).filter(([k,v])=>v).map(([k])=>k.charAt(0).toUpperCase()+k.slice(1));
      if (acts.length){
        doc.setFontSize(12);
        doc.text(`Actions: ${acts.join(', ')}`, 40, y); y += 16;
      }
      if (g.note){
        doc.setFontSize(12);
        y = wrapText(doc, `Notes: ${g.note}`, 40, y, 515); y += 8;
      }

      for (const src of g.photos){
        if (y > 680) { doc.addPage(); y = 40; }
        try { doc.addImage(src, 'JPEG', 40, y, 200, 150); } catch {}
        y += 160;
      }
      y += 6;
    }

    doc.save('CCTV-Checklist.pdf');
  }

  // helpers
  function wrapText(doc, text, x, y, maxWidth){
    const lines = doc.splitTextToSize(text, maxWidth);
    for (const line of lines){ doc.text(line, x, y); y += 14; }
    return y;
  }
  function escapeHtml(s=''){ return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
  function toast(msg){
    const t = document.createElement('div');
    t.className = 'toast';
    t.textContent = msg;
    document.body.appendChild(t);
    setTimeout(()=>t.remove(), 1300);
  }
  // Reads EXIF orientation (1..8) from a JPEG ArrayBuffer.
// Returns 1 if not found or not a JPEG/EXIF.
function readExifOrientation(arrayBuffer){
  const dv = new DataView(arrayBuffer);
  if (dv.getUint16(0, false) !== 0xFFD8) return 1; // not a JPEG
  let offset = 2;
  const length = dv.byteLength;
  while (offset < length) {
    const marker = dv.getUint16(offset, false); offset += 2;
    if (marker === 0xFFE1) { // APP1
      const exifLength = dv.getUint16(offset, false); offset += 2;
      if (dv.getUint32(offset, false) !== 0x45786966) return 1; // "Exif"
      offset += 6; // "Exif\0\0"
      const tiffOffset = offset;
      const little = dv.getUint16(tiffOffset, false) === 0x4949;
      const firstIFDOffset = dv.getUint32(tiffOffset + 4, little);
      let ifdOffset = tiffOffset + firstIFDOffset;
      const entries = dv.getUint16(ifdOffset, little); ifdOffset += 2;
      for (let i=0; i<entries; i++){
        const entryOffset = ifdOffset + i*12;
        const tag = dv.getUint16(entryOffset, little);
        if (tag === 0x0112){ // Orientation
          const val = dv.getUint16(entryOffset + 8, little);
          return val || 1;
        }
      }
      return 1;
    } else if ((marker & 0xFFF0) !== 0xFFE0) {
      break;
    } else {
      offset += dv.getUint16(offset, false);
    }
  }
  return 1;
}

// Draws an Image/Bitmap onto a canvas with EXIF orientation applied.
function drawOriented(ctx, img, width, height, orientation){
  switch (orientation) {
    case 2: ctx.translate(width, 0); ctx.scale(-1, 1); break;            // flip H
    case 3: ctx.translate(width, height); ctx.rotate(Math.PI); break;    // rotate 180
    case 4: ctx.translate(0, height); ctx.scale(1, -1); break;           // flip V
    case 5: ctx.rotate(0.5*Math.PI); ctx.scale(1, -1);                    // rotate 90 + flip V
            [width, height] = [height, width]; break;
    case 6: ctx.rotate(0.5*Math.PI); ctx.translate(0, -height);           // rotate 90 CW
            [width, height] = [height, width]; break;
    case 7: ctx.rotate(0.5*Math.PI); ctx.translate(width, -height);       // rotate 90 + flip H
            ctx.scale(-1, 1); [width, height] = [height, width]; break;
    case 8: ctx.rotate(-0.5*Math.PI); ctx.translate(-width, 0);           // rotate 90 CCW
            [width, height] = [height, width]; break;
    default: break;
  }
  return { width, height };
}

// Normalize orientation & scale; returns a JPEG dataURL
async function fixImageOrientationAndScale(file, { maxDim = 1600, quality = 0.85 } = {}){
  // 1) Read EXIF orientation
  const buf = await file.arrayBuffer();
  let orientation = 1;
  try { orientation = readExifOrientation(buf) || 1; } catch {}

  // 2) Try to load oriented pixels via createImageBitmap (many browsers support this)
  let bitmap = null;
  try {
    // imageOrientation: 'from-image' respects EXIF automatically if supported
    bitmap = await createImageBitmap(file, { imageOrientation: 'from-image' });
  } catch {
    // Fallback: load into Image (may ignore EXIF), we handle via canvas below
    const url = URL.createObjectURL(file);
    bitmap = await new Promise((res, rej) => {
      const img = new Image();
      img.onload = () => { res(img); URL.revokeObjectURL(url); };
      img.onerror = rej;
      img.src = url;
    });
  }

  // 3) Compute target size (keep aspect, limit longest side to maxDim)
  let iw = bitmap.width, ih = bitmap.height;
  let tw = iw, th = ih;
  const longSide = Math.max(iw, ih);
  if (longSide > maxDim) {
    const scale = maxDim / longSide;
    tw = Math.round(iw * scale);
    th = Math.round(ih * scale);
  }

  // If orientation rotates the image, swap target dimensions
  const rotates90 = [5,6,7,8].includes(orientation);
  const canvas = document.createElement('canvas');
  canvas.width  = rotates90 ? th : tw;
  canvas.height = rotates90 ? tw : th;

  const ctx = canvas.getContext('2d');

  // 4) Apply orientation transform and draw scaled image
  const dim = drawOriented(ctx, bitmap, canvas.width, canvas.height, orientation);
  ctx.drawImage(bitmap, 0, 0, dim.width, dim.height);

  // 5) Export as moderately compressed JPEG (smaller PDF)
  return canvas.toDataURL('image/jpeg', quality);
}

  </script>

  <!-- Service worker intentionally disabled in this baseline -->
</body>
</html>
